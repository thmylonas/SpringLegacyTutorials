How to add static CSS,JS files in the Spring MVC app (without Thymeleaf)
---------------------------------------------------------------------------
<head>
    <!-- Stylesheets -->
    <link href="/SpringMvc/resources/css/styles_general/_styles_variables.css" rel="stylesheet"/>
    <link href="/SpringMvc/resources/css/styles_general/student_alt_home.css" rel="stylesheet"/>
    <!-- Stylesheets for Bootstrap -->
    <link href="/SpringMvc/resources/css/boostrap_css_libs/bootstrap.min.css" rel="stylesheet"/>
</head>

public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**").addResourceLocations("/resources/");
    }
}

========================================================================================================================

1. Right configuration of "ComponentScan"

We have to exclude: "@ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)"
from all the Configuration classes. Otherwise, the Controllers will be called many times

@ComponentScan(basePackages = {"com.packages.path.to.app"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Repository.class),
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Controller.class),
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class RootConfig {}

@ComponentScan(basePackages = {"com.packages.path.to.controllers_directory.controllers"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class WebConfig {}

@ComponentScan(basePackages = {"com.packages.path.to.data_access_layer.daos"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class DataAccessConfig {}

2. How to use "FilterType.REGEX"

@ComponentScan(basePackages = {"com.packages.path.to.app"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = {"com\\.packages\\.path\\.to\\.app\\.data_access_layer\\..*"}),
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = {"com\\.packages\\.path\\.to\\.app\\.servlet_dispatcher_web_components\\..*"}),
        }
)
public class RootConfig {}

3. Be careful, the "@WebFilter" is not a Spring bean, and is not in the "Spring Container". It is a Web Container"'s (Tomcat) object

========================================================================================================================

<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator -->
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.1.1.Final</version>
</dependency>
The following is for @Valid annotation on @RequestBody

========================================================================================================================

Java_Version / Spring_Framework_Version [/ Spring_Data_Version]
-------------------------------------------------------------------

Wrong combination of "Java_Version / Spring_Framework_Version":
- for a "Spring_Framework_Version", if the "Java_Version" is less than the "Correct_Combination"
leads to the next error:
    Caused by: org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file -
    probably due to a new Java class file version that isn't supported yet:
    file target\spring_rest-1.0-SNAPSHOT\WEB-INF\classes\com\thomasmylonas\spring_rest\ApplicationInitializer.class;
    nested exception is java.lang.IllegalArgumentException: Unsupported class file major version 59/60/61/63/64/65

The "Correct_Combinations" of "Java_Version / Spring_Framework_Version" (after testing), are the following:
- 9 / 4.3.30.RELEASE
- 14 / 5.2.1.RELEASE [/ 2.1.9.RELEASE] [initial version in 2019]
- 19 / 5.3.22
- 21 / 5.3.39
- 6.x.x: Does not work - Needs Jakarta/Tomcat_10

========================================================================================================================

If "public class WebConfig implements WebMvcConfigurer":
- In Springframework version_4.x.xx, we need to implement all the "WebMvcConfigurer" interface's methods
- In Springframework version_5.x.xx, we DO NOT need to implement any of the "WebMvcConfigurer" interface's methods (default methods)

========================================================================================================================

Significant error
---------------------

With the URL:
- "jdbc:h2:~/studentdb;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1"
H2 needs everytime we run the project, to delete the "~/studentdb", so, it will create a new one.

Console Error:
------------------
[RMI TCP Connection(2)-127.0.0.1] ERROR org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentImpl - Could not fetch the SequenceInformation from the database
org.h2.jdbc.JdbcSQLSyntaxErrorException: Column "min_value" not found [42122-232]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:514) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.message.DbException.get(DbException.java:223) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.message.DbException.get(DbException.java:199) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.jdbc.JdbcResultSet.getColumnIndex(JdbcResultSet.java:3492) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.jdbc.JdbcResultSet.getLong(JdbcResultSet.java:745) ~[h2-2.3.232.jar:2.3.232]
	at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.resultSetMinValue(SequenceInformationExtractorLegacyImpl.java:134) ~[hibernate-core-5.4.3.Final.jar:5.4.3.Final]
	at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:60) ~[hibernate-core-5.4.3.Final.jar:5.4.3.Final]
	at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentImpl.sequenceInformationList(JdbcEnvironmentImpl.java:403) ~[hibernate-core-5.4.3.Final.jar:5.4.3.Final]
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in DataAccessConfig:
Factory method 'entityManagerFactory' threw exception; nested exception is javax.persistence.PersistenceException:
[PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.exception.SQLGrammarException: Unable to build DatabaseInformation

Cause of error:
-------------------
The error caused by the older dependency: "org.hibernate/hibernate-core/5.4.3.Final"

Solution:
-------------
Links:
- https://github.com/h2database/h2database/issues/2625
The error solved by the newer dependency: "org.hibernate/hibernate-core/5.6.1.Final"

========================================================================================================================

Other error - Not analyzed
------------------------------
org.springframework.beans.factory.UnsatisfiedDependencyException:
Error creating bean with name 'studentDao' defined in file
Unsatisfied dependency expressed through constructor parameter 0;
nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException:
Error creating bean with name 'entityManagerFactory'
defined in com.thomasmylonas.spring_rest.config.DataAccessConfig:
Unsatisfied dependency expressed through method 'entityManagerFactory' parameter 0;
nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException:
No qualifying bean of type 'javax.sql.DataSource' available: expected at least 1 bean which qualifies as autowire candidate.
Dependency annotations: {}

========================================================================================================================

The minimum Configuration to run a SpringMVC/SpringREST web application is:

@Configuration
@ComponentScan(basePackages = {"path.to.controllers"})
@EnableWebMvc
public class WebConfig {}

public class ApplicationInitializer extends org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer {
    @Override protected Class<?>[] getRootConfigClasses() {return new Class[]{RootConfig.class, DataAccessConfig.class};}
    @Override protected Class<?>[] getServletConfigClasses() {return new Class[]{WebConfig.class};}
    @Override protected String[] getServletMappings() {return new String[]{"/"};}
}

Attention:
- The "public class WebConfig implements org.springframework.web.servlet.config.annotation.WebMvcConfigurer" is NOT mandatory
- The "public class WebConfig extends org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter" is NOT mandatory

========================================================================================================================

Use of "@EnableJpaRepositories" in "Spring_Legacy"
------------------------------------------------------

In case of "Spring_Legacy" (NO "SpringBoot"), to use:
- "Spring_Data_JPA" ("org.springframework.data.jpa.repository.JpaRepository<T, ID>")
we need to add the annotation "@org.springframework.data.jpa.repository.config.EnableJpaRepositories", over the "DataAccessConfig":

    @Configuration @ComponentScan(basePackages = {...})
    @org.springframework.data.jpa.repository.config.EnableJpaRepositories(basePackages = "path.to.repositories")
    public class DataAccessConfig {...}

The "@EnableJpaRepositories" annotation in "Spring_Data_JPA" is used to enable and configure Spring's support for "JPA" repositories.
Its main function is to scan for, and create proxy implementations of repository interfaces that extend "Spring_Data" repository interfaces, such as "JpaRepository".
This allows us to define repository interfaces with methods like "findById()" or "findByLastName()",
and have Spring automatically create the necessary implementation for interacting with the database.

Basic functionalities:
- Enables repository scanning:
  By default, it scans the package of the annotated configuration class for repository interfaces.
- Specifies packages to scan:
  We can use the "basePackages" attribute to explicitly define one or more packages to scan,
  which is useful if the repositories are located in a different directory structure from the main configuration class.
- Generates repository implementations:
  Once found, Spring creates proxy objects for these interfaces, giving access to "CRUD" and custom query methods without writing any "SQL" code.
- Configures repository infrastructure:
  It provides attributes to configure various aspects of the repository infrastructure,
  such as the transaction management behavior, the "EntityManagerFactory" to use, and whether to discover nested interfaces.
- Disables default "SpringBoot" behavior:
  This annotation overrides the default behavior of "SpringBoot",
  which automatically enables "JPA" repositories based on the location of the "@SpringBootApplication" class.

========================================================================================================================

Attention:
Pont_1:
The Services in the "JsfPrimefacesTutorials", are servicing the StudentDao only.
In that case returning something in some of their methods was not useful in anything.
Their purpose was completely different.

Pont_2:
The Services in this project, are servicing an API. This means that the Service needs to follow the
pattern of the APIs. So, they need to return the resource to the Client.

========================================================================================================================

About Not_Used/Removed dependencies
---------------------------------------

Dependency_1:
-----------------

The dependencies:
- "org.springframework/spring-aop"
- "org.springframework/spring-beans"
- "org.springframework/spring-context"
- "org.springframework/spring-core"
- "org.springframework/spring-expression"
- "org.springframework/spring-web"
are covered from:
- the dependency "org.springframework/spring-webmvc" (exist in this dependency's "pom.xml" file)

Dependency_2:
-----------------

The dependencies:
- "com.fasterxml.jackson.core/jackson-core"
- "com.fasterxml.jackson.core/jackson-annotations"
are removed from "pom.xml" file, because they are covered from:
- the dependency "com.fasterxml.jackson.core/jackson-databind" (exist in this dependency's "pom.xml" file)

<dependency> <!-- Removed -->
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.13.3</version>
</dependency>
<dependency> <!-- Removed -->
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.13.3</version>
</dependency>


Dependency_3:
-----------------

The dependencies:
- "org.apache.tomcat/tomcat-servlet-api" (no need for extra dependency)
- "org.apache.tomcat/tomcat-jsp-api" (no need for extra dependency)
are covered from:
- the dependency "org.apache.tomcat/tomcat-catalina" (exist in this dependency's "pom.xml" file)

========================================================================================================================

Jackson-serialization of "LocalDate/LocalDateTime" fields
-------------------------------------------------------------

Links:
- https://stackoverflow.com/questions/29956175/json-java-8-localdatetime-format-in-spring-boot
- https://stackoverflow.com/questions/53820977/jackson-converting-localdatetime

In the next classes/records, we use "LocalDate/LocalDateTime" fields:

    public record StudentResponseDto(
            @JsonSerialize(using = LocalDateSerializer.class)
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy")
            LocalDate dateOfBirth,
            // ...
    ){}

    public record ResponseSuccess(
            @JsonSerialize(using = LocalDateTimeSerializer.class)
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy HH:mm:ss")
            LocalDateTime timestamp,
            // ...
    ){}

    public record ResponseError(
            @JsonSerialize(using = LocalDateTimeSerializer.class)
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy HH:mm:ss")
            LocalDateTime timestamp,
            // ...
    ){}

These "LocalDate/LocalDateTime" fields to be able to be JSON-serialized, it is mandatory to add on them, the next annotations:
- @com.fasterxml.jackson.databind.annotation.JsonSerialize(using = com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer.class)
- @com.fasterxml.jackson.databind.annotation.JsonSerialize(using = com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer.class)
These annotations are part of the dependency "com.fasterxml.jackson.datatype/jackson-datatype-jsr310".
In the opposite case Jackson library will end up to serialization errors.

It seems that (I am not sure if this is correct) the next 2 points are valid:
- [I am not sure] If the dependency "com.fasterxml.jackson.datatype/jackson-datatype-jsr310" exists in the "pom.xml",
  these 2 annotations are not needed at all.
- [I am not sure] Jackson makes an "Autoconfiguration", and adds these annotations by itself.

Note:
In these "SpringLegacyTutorials", the "com.fasterxml.jackson.*" dependencies are added in the "pom.xml" manually.
In "SpringBoot", the "com.fasterxml.jackson.*" dependencies are provided by the "org.springframework.boot/spring-boot-dependencies".

========================================================================================================================

MultipartFormData

--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="firstName"

Charles
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="lastName"

Xavier
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="email"

charles@xmen.com
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="username"

professorx
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="password"

letmein01
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="profilePicture"; filename="me.jpg"
Content-Type: image/jpeg

[[ Binary image data goes here ]]
--WebKitFormBoundaryqgkaBn8IHJCuNmiW--

------------------------------

public class ApplicationInitializer extends org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer {

    // ...

    /**
     * We override this method, when we want to deal with "multipart-form data".
     * This method is inherited from "AbstractDispatcherServletInitializer"
     *
     * @param registration The "javax.servlet.ServletRegistration.Dynamic"
     */
    @Override
    protected void customizeRegistration(javax.servlet.ServletRegistration.Dynamic registration) {
        registration.setMultipartConfig(new javax.servlet.MultipartConfigElement("/path/to/uploads"));
    }
}

========================================================================================================================

Using "Multiple_Resolvers"
------------------------------

@org.springframework.context.annotation.Configuration
@org.springframework.context.annotation.ComponentScan(basePackages = {"com.thomasmylonas.spring_mvc"})
@org.springframework.web.servlet.config.annotation.EnableWebMvc
public class MultipleResolversConfig {
    /**
     * Link:
     * - https://stackoverflow.com/questions/25055610/creating-multiple-internalresourceviewresolver
     * We can only have one of the "InternalResourceViewResolver" in the context, because of the same reason mentioned in the Javadoc:
     * <p>
     * * <Javadoc>
     * * When chaining ViewResolvers, an "org.springframework.web.servlet.view.InternalResourceViewResolver" always needs to be last,
     * * as it will attempt to resolve any view name, no matter whether the underlying resource actually exists.
     * * </Javadoc>
     * <p>
     * The "org.springframework.web.servlet.view.InternalResourceViewResolver" always returns an answer (because it just delegates to the Servlet API,
     * which always has an answer, even if it's wrong), so having two of them won't get solution, since the 2nd one will never be consulted.
     *
     * @return The ViewResolver
     */
    @org.springframework.context.annotation.Bean
    public org.springframework.web.servlet.ViewResolver viewResolver() {
        org.springframework.web.servlet.view.InternalResourceViewResolver viewResolver = new org.springframework.web.servlet.view.InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/views/");
        viewResolver.setSuffix(""); //viewResolver.setSuffix(".html");viewResolver.setSuffix(".xhtml");
        viewResolver.setOrder(101); //viewResolver.setOrder(100); // InternalResourceViewResolver - lowest priority
        viewResolver.setExposeContextBeansAsAttributes(true);
        return viewResolver;
    }
}

========================================================================================================================

Run/Debug Configurations
----------------------------

Tomcat Server > Tomcat_v9.x.xx
Name: Tomcat_v9.x.xx

Server Tab
--------------
Application server: Tomcat_v9.x.xx
Open browser:
    - After launch > Default
    - URL: http://localhost:8080/Xxxx
On 'Update' action: Update resources [Appears only with: "war_exploded_artifact"]
On frame deactivation: Update resources [Appears only with: "war_exploded_artifact"]
JRE: xxx
Tomcat Server Settings:
    HTTP port: 8080
Before launch:
    - Run Maven Goal 'Xxxx: clean'
    - Build
    - Build 'jsf_primefaces_tutorials:war exploded' artifact

Deployment Tab
------------------
Deploy at the server startup
    - jsf_primefaces_tutorials:war exploded
Application context: /Xxxx [Hidden at the end of Tab]
                    [Default value: "/Xxxx_war" or "/Xxxx_war_exploded"]

========================================================================================================================

Run/Debug Configurations
----------------------------

Deployment Tab
------------------
Deploy at the server startup
    - xx_xx:war exploded
Application context: / [Hidden at the end of Tab] <---- [Attention: The path has to be "/"]
                    [Default value: "/Xxxx_war" or "/Xxxx_war_exploded"]

Attention:
In the "Run/Debug Configurations > Deployment Tab > Application context" has to be "/"
Different values, in combination with the:
- ApplicationInitializer::getServletMappings

....

========================================================================================================================

About the SpringREST module
-------------------------------

This is Legacy SpringREST API:
This means:
- Legacy Spring configuration
- Legacy use of Annotations

In this API will not contain:
- Validation Code using any validation library
- No use of "Spring_Data_JPA" ("org.springframework.data.jpa.repository.JpaRepository<T, ID>")
- HATEOAS
- Return the "stacktrace"
- The names as long they finalized, will not be changed

In this API the validation will be done manually, as it is done in the "StudentDao"

========================================================================================================================
