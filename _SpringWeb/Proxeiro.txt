How to add static CSS,JS files in the Spring MVC app (without Thymeleaf)
---------------------------------------------------------------------------
<head>
    <!-- Stylesheets -->
    <link href="/JsfPrimefacesTutorials/resources/css/styles_general/_styles_variables.css" rel="stylesheet"/>
    <link href="/JsfPrimefacesTutorials/resources/css/styles_general/student_alt_home.css" rel="stylesheet"/>
    <!-- Stylesheets for Bootstrap -->
    <link href="/JsfPrimefacesTutorials/resources/css/boostrap_css_libs/bootstrap.min.css" rel="stylesheet"/>
</head>

public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**").addResourceLocations("/resources/");
    }
}

========================================================================================================================

1. Right configuration of "ComponentScan"

We have to exclude: "@ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)"
from all the Configuration classes. Otherwise, the Controllers will be called many times

@ComponentScan(basePackages = {"com.packages.path.to.app"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Repository.class),
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Controller.class),
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class RootConfig {}

@ComponentScan(basePackages = {"com.packages.path.to.controllers_directory.controllers"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class WebConfig {}

@ComponentScan(basePackages = {"com.packages.path.to.data_access_layer.repositories"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class DataAccessConfig {}

2. How to use "FilterType.REGEX"

@ComponentScan(basePackages = {"com.packages.path.to.app"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = {"com\\.packages\\.path\\.to\\.app\\.data_access_layer\\..*"}),
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = {"com\\.packages\\.path\\.to\\.app\\.servlet_dispatcher_web_components\\..*"}),
        }
)
public class RootConfig {}

3. Be careful, the "@WebFilter" is not a Spring bean, and is not in the "Spring Container". It is a Web Container"'s (Tomcat) object

========================================================================================================================

<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator -->
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.1.1.Final</version>
</dependency>
The following is for @Valid annotation on @RequestBody

========================================================================================================================

Move to JSF
WebConfig.java
---------------
@Configuration
@ComponentScan(basePackages = {"com.thomasmylonas.spring_rest.controllers"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    /**
     * This method replaces fully the configuration in "web.xml"
     * To enable the configuration with this class, we have to add in the "WebConfig" class the following annotation:
     * "@ServletComponentScan(basePackages = {"com.thomasmylonas.spring_mvc_jsf_pf_web_app"})"
     *
     * @param servletContext The ServletContext
     * @return The ServletRegistrationBean
     */
    //@Bean
    ServletRegistrationBean<FacesServlet> facesServletRegistration(javax.servlet.ServletContext servletContext) {

        // Spring Boot works only, if this is set
        servletContext.setInitParameter("com.sun.faces.forceLoadConfiguration", Boolean.TRUE.toString());
        servletContext.setInitParameter("javax.faces.FACELETS_SKIP_COMMENTS", Boolean.TRUE.toString());
        // Use JSF view templates saved as *.xhtml, for use with Facelets
        servletContext.setInitParameter("javax.faces.DEFAULT_SUFFIX", ".xhtml");
        servletContext.setInitParameter("javax.faces.CONFIG_FILES", "/WEB-INF/faces-config.xml");

        // This parameter enables better error messages, including in the client-side JavaScript, at the cost of some performance
        //servletContext.setInitParameter("javax.faces.PROJECT_STAGE", "Development");
        // State saving method: 'client' or 'server' (=default)
        //servletContext.setInitParameter("javax.faces.STATE_SAVING_METHOD", "client");

        // FacesServlet registration
        ServletRegistrationBean<FacesServlet> servletRegistrationBean = new ServletRegistrationBean<>();
        servletRegistrationBean.setServlet(new FacesServlet());
        servletRegistrationBean.setUrlMappings(Arrays.asList("*.xhtml", "*.jsf", "/faces/*", "*.faces"));
        servletRegistrationBean.setLoadOnStartup(1);
        return servletRegistrationBean;
    }
}

========================================================================================================================

If "public class WebConfig implements WebMvcConfigurer":
- In Springframework version_4.x.xx, we need to implement all the "WebMvcConfigurer" interface's methods
- In Springframework version_5.3.22, we DO NOT need to implement any of the "WebMvcConfigurer" interface's methods (default methods)

========================================================================================================================

Attention:
Pont_1:
The Services in the "JsfPrimefacesTutorials", are servicing the StudentDao only.
In that case returning something in some of their methods was not useful in anything.
Their purpose was completely different.

Pont_2:
The Services in this project, are servicing an API. This means that the Service needs to follow the
pattern of the APIs. So, they need to return the resource to the Client.
