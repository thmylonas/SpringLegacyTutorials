How to add static CSS,JS files in the Spring MVC app (without Thymeleaf)
----------------------------------------------------------------------------

<head>
    <!-- Stylesheets -->
    <link rel="stylesheet" href="/resources/css/styles.css"/>
    <link rel="stylesheet" href="/resources/css/boostrap_css_libs/bootstrap_v4.6.1/bootstrap.min.css"/>
</head>

public class WebConfig implements WebMvcConfigurer {
    @Override public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**").addResourceLocations("/resources/");
    }
}

========================================================================================================================

1. Right configuration of "ComponentScan"

We have to exclude: "@ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)"
from all the Configuration classes. Otherwise, the Controllers will be called many times

@ComponentScan(basePackages = {"com.packages.path.to.app"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Repository.class),
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Controller.class),
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class RootConfig {}

@ComponentScan(basePackages = {"com.packages.path.to.controllers_directory.controllers"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class WebConfig {}

@ComponentScan(basePackages = {"com.packages.path.to.data_access_layer.daos"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Configuration.class)
        }
)
public class DataAccessConfig {}

2. How to use "FilterType.REGEX"

@ComponentScan(basePackages = {"com.packages.path.to.app"},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = {"com\\.packages\\.path\\.to\\.app\\.data_access_layer\\..*"}),
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = {"com\\.packages\\.path\\.to\\.app\\.servlet_dispatcher_web_components\\..*"}),
        }
)
public class RootConfig {}

3. Be careful, the "@WebFilter" is not a Spring bean, and is not in the "Spring Container". It is a Web Container"'s (Tomcat) object

========================================================================================================================

Java_Version / Spring_Framework_Version [/ Spring_Data_Version]
-------------------------------------------------------------------

Wrong combination of "Java_Version / Spring_Framework_Version":
- for a "Spring_Framework_Version", if the "Java_Version" is less than the "Correct_Combination"
leads to the next error:
    Caused by: org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file -
    probably due to a new Java class file version that isn't supported yet:
    file target\spring_rest-1.0-SNAPSHOT\WEB-INF\classes\com\thomasmylonas\spring_rest\ApplicationInitializer.class;
    nested exception is java.lang.IllegalArgumentException: Unsupported class file major version 59/60/61/63/64/65

The "Correct_Combinations" of "Java_Version / Spring_Framework_Version" (after testing), are the following:
- 9 / 4.3.30.RELEASE
- 14 / 5.2.1.RELEASE [/ 2.1.9.RELEASE] [initial version in 2019]
- 19 / 5.3.22
- 21 / 5.3.39
- 6.x.x: Does not work - Needs Jakarta/Tomcat_10

========================================================================================================================

If "public class WebConfig implements WebMvcConfigurer":
- In Springframework version_4.x.xx, we need to implement all the "WebMvcConfigurer" interface's methods
- In Springframework version_5.x.xx, we DO NOT need to implement any of the "WebMvcConfigurer" interface's methods (default methods)

========================================================================================================================

The minimum Configuration to run a SpringMVC/SpringREST web application is:

@Configuration
@ComponentScan(basePackages = {"path.to.controllers"})
@EnableWebMvc
public class WebConfig {}

public class ApplicationInitializer extends org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer {
    @Override protected Class<?>[] getRootConfigClasses() {return new Class[]{RootConfig.class, DataAccessConfig.class};}
    @Override protected Class<?>[] getServletConfigClasses() {return new Class[]{WebConfig.class};}
    @Override protected String[] getServletMappings() {return new String[]{"/"};}
}

Attention:
- The "public class WebConfig implements org.springframework.web.servlet.config.annotation.WebMvcConfigurer" is NOT mandatory
- The "public class WebConfig extends org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter" is NOT mandatory

========================================================================================================================

[SpringRest] APIs Validation
--------------------------------
In "SpringLegacy" to make APIs Validation (use of "@Valid"), we need the next dependency:
- "org.hibernate/hibernate-validator/7.0.1.Final" // 6.1.1.Final

========================================================================================================================

[SpringRest] Use of "@EnableJpaRepositories" in "Spring_Legacy/SpringRest"
------------------------------------------------------------------------------

In case of "Spring_Legacy" (NO "SpringBoot"), to use:
- "Spring_Data_JPA" ("org.springframework.data.jpa.repository.JpaRepository<T, ID>")
we need to add the annotation "@org.springframework.data.jpa.repository.config.EnableJpaRepositories", over the "DataAccessConfig":

    @Configuration @ComponentScan(basePackages = {...})
    @org.springframework.data.jpa.repository.config.EnableJpaRepositories(basePackages = "path.to.repositories")
    public class DataAccessConfig {...}

The "@EnableJpaRepositories" annotation in "Spring_Data_JPA" is used to enable and configure Spring's support for "JPA" repositories.
Its main function is to scan for, and create proxy implementations of repository interfaces that extend "Spring_Data" repository interfaces, such as "JpaRepository".
This allows us to define repository interfaces with methods like "findById()" or "findByLastName()",
and have Spring automatically create the necessary implementation for interacting with the database.

Basic functionalities:
- Enables repository scanning:
  By default, it scans the package of the annotated configuration class for repository interfaces.
- Specifies packages to scan:
  We can use the "basePackages" attribute to explicitly define one or more packages to scan,
  which is useful if the repositories are located in a different directory structure from the main configuration class.
- Generates repository implementations:
  Once found, Spring creates proxy objects for these interfaces, giving access to "CRUD" and custom query methods without writing any "SQL" code.
- Configures repository infrastructure:
  It provides attributes to configure various aspects of the repository infrastructure,
  such as the transaction management behavior, the "EntityManagerFactory" to use, and whether to discover nested interfaces.
- Disables default "SpringBoot" behavior:
  This annotation overrides the default behavior of "SpringBoot",
  which automatically enables "JPA" repositories based on the location of the "@SpringBootApplication" class.

Significant Note:
---------------------
"SpringBoot" automatically enables "JPA" repositories based on the location of the "@SpringBootApplication" class.
So, there is no need to use the Annotation:
- @org.springframework.data.jpa.repository.config.EnableJpaRepositories(basePackages = "path.to.repositories")

========================================================================================================================

[SpringRest] About the Services
-----------------------------------

Point_1:
The Services in the "JsfPrimefacesTutorials", are servicing the StudentDao only.
In that case returning something from some of their methods was not useful in anything.
Their purpose was completely different.

Point_2:
The Services in the "SpringRest" module, are servicing an API. This means that the Service needs to follow the pattern of the APIs.
So, they need to return the resource to the Client.

========================================================================================================================

About Not_Used/Removed dependencies
---------------------------------------

Dependency_1:
-----------------

The dependency "org.springframework/spring-context" covers the dependencies (exist in this dependency's "pom.xml" file):
- "org.springframework/spring-beans"
- "org.springframework/spring-core"
- "org.springframework/spring-expression"
- "org.springframework/spring-aop"

Dependency_2:
-----------------

The dependency "org.springframework/spring-webmvc" covers the dependencies (exist in this dependency's "pom.xml" file):
- "org.springframework/spring-beans"
- "org.springframework/spring-core"
- "org.springframework/spring-expression"
- "org.springframework/spring-aop"
- "org.springframework/spring-context"
- "org.springframework/spring-web"

Dependency_3:
-----------------

The dependency "org.springframework/spring-hibernate" covers the dependencies (exist in this dependency's "pom.xml" file):
- "org.springframework/spring-beans"
- "org.springframework/spring-core"
- "org.springframework/spring-aop"
- "org.springframework/spring-jdbc" (lower lever than the "org.springframework/spring-data-jdbc")
- "org.springframework/spring-dao"
- "org.springframework/spring-orm"
- "org.springframework/spring-web"
- "org.springframework/spring-webmvc"
- "org.hibernate/hibernate" (older version than the "org.hibernate/hibernate-core")
- "javax.servlet/servlet-api" (fewer features than "javax.servlet/javax.servlet-api")

Dependency_4:
-----------------

The dependency "org.springframework.data/spring-data-jpa" covers the dependencies (exist in this dependency's "pom.xml" file):
- "org.springframework.data/spring-data-commons"
- and others

Dependency_5:
-----------------

The dependency "org.springframework.hateoas/spring-hateoas" covers the dependencies (exist in this dependency's "pom.xml" file):
- "org.springframework.plugin/spring-plugin-core" (I do not know what it is used for)
- and others

Dependency_6:
-----------------

The dependency "org.springframework.plugin/spring-plugin-core", I do not know what it is used for.

Dependency_7:
-----------------

The dependency "org.springframework/spring-context-support" provides support for integrating common third-party libraries
into a Spring application context for:
- Caching (EhCache, Guava, JCache),
- Mailing (JavaMail),
- Scheduling (CommonJ, Quartz), and
- Template engines (FreeMarker, JasperReports, Velocity)

Dependency_8:
-----------------

The dependency "org.hibernate/hibernate-entitymanager" was mandatory, in older versions of "hibernate".

Dependency_9:
-----------------

The dependency "javax/javaee-web-api" covers the dependencies (exist in this dependency's "pom.xml" file):
- "javax.servlet/javax.servlet-api"
- "javax.servlet.jsp/javax.servlet.jsp-api"
- "javax.el/javax.el-api" (Covered from the dependency "com.sun.faces/jsf-api" (exists in this dependency's "pom.xml" file))
- "javax.servlet.jsp.jstl/javax.servlet.jsp.jstl-api"
- "org.glassfish/javax.faces"
- "javax.faces/javax.faces-api"
- "javax.ws.rs/javax.ws.rs-api"
- "javax.websocket"
- "javax.websocket-api"
- "javax.json/javax.json-api"
- "javax.annotation/javax.annotation-api"
- "javax.ejb/javax.ejb-api"
- "javax.transaction/javax.transaction-api"
- "org.eclipse.persistence/javax.persistence"
- "javax.validation/validation-api"
- "javax.interceptor/javax.interceptor-api"
- "javax.enterprise/cdi-api"
- "javax.inject/javax.inject"

Dependency_10:
------------------

The dependency "javax.mvc/javax.mvc-api" covers the dependencies (exist in this dependency's "pom.xml" file):
- "jakarta.ws.rs/jakarta.ws.rs-api"
- "javax.enterprise/cdi-api"
- "javax.validation/validation-api"
- "jakarta.annotation/jakarta.annotation-api"

Dependency_11:
------------------

The dependency "com.fasterxml.jackson.core/jackson-databind" covers the dependencies (exist in this dependency's "pom.xml" file):
- "com.fasterxml.jackson.core/jackson-core"
- "com.fasterxml.jackson.core/jackson-annotations"

So, they are removed from "pom.xml" file:
<dependency> <!-- Removed -->
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.13.3</version>
</dependency>
<dependency> <!-- Removed -->
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.13.3</version>
</dependency>

Dependency_12:
------------------

Link:
- https://github.com/FasterXML/jackson-dataformat-xml

The dependency "com.fasterxml.jackson.dataformat/jackson-dataformat-xml" contains Jackson extension component for:
- reading and writing XML encoded data
- supporting "JAXB" annotations, which are provided by "JAXB" annotation module

Dependency_13:
------------------

The dependency "org.apache.tomcat/tomcat-catalina" covers the dependencies (exist in this dependency's "pom.xml" file):
- "org.apache.tomcat/tomcat-servlet-api" (no need for extra dependency)
- "org.apache.tomcat/tomcat-jsp-api" (no need for extra dependency)

Dependency_14:
------------------

Links:
- https://stackoverflow.com/questions/4711943/tomcat-dbcp-vs-commons-dbcp
- https://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html#Introduction

The dependencies:
- "org.apache.tomcat/tomcat-dbcp" (renamed version of "org.apache.commons/commons-dbcp2")
- "org.apache.commons/commons-dbcp2"
are removed from "pom.xml" file, because I do not know what they are used for.

<dependency> <!-- Removed -->
    <groupId>org.apache.tomcat</groupId>
    <artifactId>tomcat-dbcp</artifactId>
    <version>9.0.30</version>
</dependency>

Dependency_15:
------------------

The dependency "directory-naming/naming-java" is removed from "pom.xml" file, because I do not know what it is used for.
The right dependency which should be used is "javax.naming/jndi".
Although the dependency "javax.naming/jndi" is part of Java_EE dependencies,
it seems (I am not sure) that is used from Tomcat server.
I guess (I am not sure), that the dependency "javax.naming/jndi" is covered by the dependency "org.apache.tomcat/tomcat-catalina/9.0.58".

<dependency> <!-- Removed -->
    <groupId>directory-naming</groupId>
    <artifactId>naming-java</artifactId>
    <version>0.8</version>
    <scope>test</scope>
</dependency>

Dependency_16:
------------------

The dependencies:
- "org.hibernate.javax.persistence/hibernate-jpa-2.1-api"
- "unknown.binary/hibernate-jpamodelgen-4.3.1.Final"
I do not know what they are used for.

========================================================================================================================

Jackson-serialization of "LocalDate/LocalDateTime" fields
-------------------------------------------------------------

Links:
- https://stackoverflow.com/questions/29956175/json-java-8-localdatetime-format-in-spring-boot
- https://stackoverflow.com/questions/53820977/jackson-converting-localdatetime

In the next classes/records, we use "LocalDate/LocalDateTime" fields:

    public record StudentResponseDto(
            @JsonSerialize(using = LocalDateSerializer.class)
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy")
            LocalDate dateOfBirth,
            // ...
    ){}

    public record ResponseSuccess(
            @JsonSerialize(using = LocalDateTimeSerializer.class)
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy HH:mm:ss")
            LocalDateTime timestamp,
            // ...
    ){}

    public record ResponseError(
            @JsonSerialize(using = LocalDateTimeSerializer.class)
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy HH:mm:ss")
            LocalDateTime timestamp,
            // ...
    ){}

These "LocalDate/LocalDateTime" fields to be able to be JSON-serialized, it is mandatory to add on them, the next annotations:
- @com.fasterxml.jackson.databind.annotation.JsonSerialize(using = com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer.class)
- @com.fasterxml.jackson.databind.annotation.JsonSerialize(using = com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer.class)
These annotations are part of the dependency "com.fasterxml.jackson.datatype/jackson-datatype-jsr310".
In the opposite case Jackson library will end up to serialization errors.

It seems that (I am not sure if this is correct) the next 2 points are valid:
- [I am not sure] If the dependency "com.fasterxml.jackson.datatype/jackson-datatype-jsr310" exists in the "pom.xml",
  these 2 annotations are not needed at all.
- [I am not sure] Jackson makes an "Autoconfiguration", and adds these annotations by itself.

Note:
In these "SpringLegacyTutorials", the "com.fasterxml.jackson.*" dependencies are added in the "pom.xml" manually.
In "SpringBoot", the "com.fasterxml.jackson.*" dependencies are provided by the "org.springframework.boot/spring-boot-dependencies".

========================================================================================================================

MultipartFormData

--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="firstName"

Charles
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="lastName"

Xavier
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="email"

charles@xmen.com
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="username"

professorx
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="password"

letmein01
--WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="profilePicture"; filename="me.jpg"
Content-Type: image/jpeg

[[ Binary image data goes here ]]
--WebKitFormBoundaryqgkaBn8IHJCuNmiW--

------------------------------

public class ApplicationInitializer extends org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer {
    /**
     * We override this method, when we want to deal with "multipart-form data".
     * This method is inherited from "AbstractDispatcherServletInitializer"
     *
     * @param registration The "javax.servlet.ServletRegistration.Dynamic"
     */
    @Override
    protected void customizeRegistration(javax.servlet.ServletRegistration.Dynamic registration) {
        registration.setMultipartConfig(new javax.servlet.MultipartConfigElement("/path/to/uploads"));
    }
    // ...
}

========================================================================================================================

Using "Multiple_Resolvers"
------------------------------

@org.springframework.context.annotation.Configuration
@org.springframework.context.annotation.ComponentScan(basePackages = {"com.thomasmylonas.spring_mvc"})
@org.springframework.web.servlet.config.annotation.EnableWebMvc
public class MultipleResolversConfig {
    /**
     * Link:
     * - https://stackoverflow.com/questions/25055610/creating-multiple-internalresourceviewresolver
     * We can only have one of the "InternalResourceViewResolver" in the context, because of the same reason mentioned in the Javadoc:
     * <p>
     * * <Javadoc>
     * * When chaining ViewResolvers, an "org.springframework.web.servlet.view.InternalResourceViewResolver" always needs to be last,
     * * as it will attempt to resolve any view name, no matter whether the underlying resource actually exists.
     * * </Javadoc>
     * <p>
     * The "org.springframework.web.servlet.view.InternalResourceViewResolver" always returns an answer (because it just delegates to the Servlet API,
     * which always has an answer, even if it's wrong), so having two of them won't get solution, since the 2nd one will never be consulted.
     *
     * @return The ViewResolver
     */
    @org.springframework.context.annotation.Bean
    public org.springframework.web.servlet.ViewResolver viewResolver() {
        org.springframework.web.servlet.view.InternalResourceViewResolver viewResolver = new org.springframework.web.servlet.view.InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/views/");
        viewResolver.setSuffix(""); //viewResolver.setSuffix(".html");viewResolver.setSuffix(".xhtml");
        viewResolver.setOrder(101); //viewResolver.setOrder(100); // InternalResourceViewResolver - lowest priority
        viewResolver.setExposeContextBeansAsAttributes(true);
        return viewResolver;
    }
}

========================================================================================================================

The "InternalResourceViewResolver::setViewClass(org.springframework.web.servlet.view.JstlView.class);"
----------------------------------------------------------------------------------------------------------

Links:
- https://stackoverflow.com/questions/32459400/why-do-i-need-a-view-class-to-resolve-jstl-views-in-spring-mvc
- https://stackoverflow.com/questions/20268095/java-lang-noclassdeffounderror-javax-servlet-jsp-jstl-core-config

The need of: "InternalResourceViewResolver::setViewClass(JstlView.class);"
------------------------------------------------------------------------------

In older Spring versions there was not "Automatic_Detection" of features. This has been introduced slowly in different Spring versions.
The "InternalResourceViewResolver" did not have "Automatic_Detection" of "JSTL" in the early days,
so it was required to always specify the "JstlView" as the viewClass, through the "Line_1" in the "WebConfig::viewResolver",
like the following code snippet:

    @Configuration @EnableWebMvc
    public class WebConfig {
        @Bean public ViewResolver viewResolver() {
            InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
            viewResolver.setViewClass(org.springframework.web.servlet.view.JstlView.class); // Add this "Line_1"
            // ...
        }
    }

However, in newer versions of Spring has been added the feature "Automatic_Detection" of which viewClass to use.
The addition was adding the next:
- "InternalResourceViewResolver" uses "JstlView" as default (instead of "InternalResourceView") if the "JSTL"-API is present
So the previous "Line_1" in the "WebConfig::viewResolver", is not needed any more.

Error caused by: "InternalResourceViewResolver::setViewClass(JstlView.class);"
----------------------------------------------------------------------------------

[Error1-500: In my tutorials]
HTTP Status 500 â€“ Internal Server Error
Message Handler processing failed; nested exception is java.lang.NoClassDefFoundError: javax/servlet/jsp/jstl/core/Config
Description The server encountered an unexpected condition that prevented it from fulfilling the request.
Exception:
org.springframework.web.util.NestedServletException: Handler processing failed; nested exception is java.lang.NoClassDefFoundError: javax/servlet/jsp/jstl/core/Config
	org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1095)
java.lang.NoClassDefFoundError: javax/servlet/jsp/jstl/core/Config
	org.springframework.web.servlet.support.JstlUtils.exposeLocalizationContext(JstlUtils.java:103)
	org.springframework.web.servlet.view.JstlView.exposeHelpers(JstlView.java:137)
	org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:145)

Solution:
-------------
"JSTL" is provided out the box by a full-fledged "Java_EE_Container" such as:
- "TomEE", "JBoss" "AS/EAP/WildFly", "Payara/GlassFish", "WebLogic", etc.
but not by barebones "JSP/Servlet_Containers" such as:
- Tomcat and Jetty
So, we need to add in the "pom.xml" the dependency:
- "javax.servlet/jstl/1.2"

========================================================================================================================

Questions/Problems/Issues
-----------------------------

Significant error
---------------------

With the URL:
- "jdbc:h2:~/studentdb;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1"
H2 needs everytime we run the project, to delete the "~/studentdb", so, it will create a new one.

Console Error:
------------------
[RMI TCP Connection(2)-127.0.0.1] ERROR org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentImpl - Could not fetch the SequenceInformation from the database
org.h2.jdbc.JdbcSQLSyntaxErrorException: Column "min_value" not found [42122-232]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:514) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.message.DbException.get(DbException.java:223) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.message.DbException.get(DbException.java:199) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.jdbc.JdbcResultSet.getColumnIndex(JdbcResultSet.java:3492) ~[h2-2.3.232.jar:2.3.232]
	at org.h2.jdbc.JdbcResultSet.getLong(JdbcResultSet.java:745) ~[h2-2.3.232.jar:2.3.232]
	at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.resultSetMinValue(SequenceInformationExtractorLegacyImpl.java:134) ~[hibernate-core-5.4.3.Final.jar:5.4.3.Final]
	at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:60) ~[hibernate-core-5.4.3.Final.jar:5.4.3.Final]
	at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentImpl.sequenceInformationList(JdbcEnvironmentImpl.java:403) ~[hibernate-core-5.4.3.Final.jar:5.4.3.Final]
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in DataAccessConfig:
Factory method 'entityManagerFactory' threw exception; nested exception is javax.persistence.PersistenceException:
[PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.exception.SQLGrammarException: Unable to build DatabaseInformation

Cause of error:
-------------------
The error caused by the older dependency: "org.hibernate/hibernate-core/5.4.3.Final"

Solution:
-------------
Links:
- https://github.com/h2database/h2database/issues/2625
The error solved by the newer dependency: "org.hibernate/hibernate-core/5.6.1.Final"

========================================================================================================================

Other error - Not analyzed
------------------------------
org.springframework.beans.factory.UnsatisfiedDependencyException:
Error creating bean with name 'studentDao' defined in file
Unsatisfied dependency expressed through constructor parameter 0;
nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException:
Error creating bean with name 'entityManagerFactory'
defined in com.thomasmylonas.spring_rest.config.DataAccessConfig:
Unsatisfied dependency expressed through method 'entityManagerFactory' parameter 0;
nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException:
No qualifying bean of type 'javax.sql.DataSource' available: expected at least 1 bean which qualifies as autowire candidate.
Dependency annotations: {}

========================================================================================================================
